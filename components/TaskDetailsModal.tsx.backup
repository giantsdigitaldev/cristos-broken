import { COLORS, SIZES } from '@/constants';
import { useAuth } from '@/contexts/AuthContext';
import { useTheme } from '@/theme/ThemeProvider';
import { Project, ProjectService, Task } from '@/utils/projectServiceWrapper';
import { Ionicons } from '@expo/vector-icons';
import React, { useEffect, useMemo, useRef, useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Animated,
  FlatList,
  Keyboard,
  Modal,
  Platform,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View
} from 'react-native';
import CalendarBottomSheetModal from './CalendarBottomSheetModal';
import SubtaskCard from './SubtaskCard';
import TaskReassignmentModal from './TaskReassignmentModal';
import Toast from './Toast';
import UserAvatar from './UserAvatar';

interface TaskDetailsModalProps {
  visible: boolean;
  onClose: () => void;
  project: Project | null;
  tasks: Task[];
  currentTaskIndex: number;
  onTaskUpdate: (taskId: string, updates: any) => void;
  onTaskDelete: (taskId: string) => void;
}

const TaskDetailsModal: React.FC<TaskDetailsModalProps> = ({
  visible,
  onClose,
  project,
  tasks,
  currentTaskIndex,
  onTaskUpdate,
  onTaskDelete,
}) => {
  const { colors, dark } = useTheme();
  const { user } = useAuth();
  
  // State
  const [currentIndex, setCurrentIndex] = useState(currentTaskIndex);
  const [task, setTask] = useState<Task | null>(null);
  const [subtasks, setSubtasks] = useState<any[]>([]);
  const [comments, setComments] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [editingField, setEditingField] = useState<string | null>(null);
  const [editValue, setEditValue] = useState('');
  const [newComment, setNewComment] = useState('');
  const [isPostingComment, setIsPostingComment] = useState(false);
  
  // Reassignment state
  const [showReassignmentModal, setShowReassignmentModal] = useState(false);
  const [assignedUsers, setAssignedUsers] = useState<any[]>([]);
  
  // Modal state
  const [keyboardVisible, setKeyboardVisible] = useState(false);
  const [keyboardHeight, setKeyboardHeight] = useState(0);
  const [showDatePicker, setShowDatePicker] = useState(false);
  
  // Subtask state
  const [showSubtaskInput, setShowSubtaskInput] = useState(false);
  const [newSubtaskText, setNewSubtaskText] = useState('');
  
  // Toast state
  const [toast, setToast] = useState({
    visible: false,
    message: '',
    type: 'success' as 'success' | 'error' | 'warning' | 'info',
  });
  
  // Delete confirmation modal state
  const [showDeleteConfirmation, setShowDeleteConfirmation] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // Animation values
  const overlayOpacity = useRef(new Animated.Value(0)).current;
  const modalAnimation = useRef(new Animated.Value(0)).current;
  const confirmationAnimation = useRef(new Animated.Value(0)).current;
  const scrollViewRef = useRef<ScrollView>(null);
  const commentInputRef = useRef<TextInput>(null);
  const descriptionInputRef = useRef<TextInput>(null);
  const subtaskInputRef = useRef<TextInput>(null);
  
  // Function to scroll input field to exact position above keyboard (mobile only)
  const scrollToInputField = (inputRef: React.RefObject<TextInput | null>, fieldType: string) => {
    // Only work on mobile platforms
    if (Platform.OS === 'web') return;
    if (!inputRef.current) return;
    
    // Simple and reliable approach for mobile
    const performScroll = () => {
      // Get current keyboard height
      const currentKeyboardHeight = keyboardHeight || 0;
      
      if (currentKeyboardHeight > 0) {
        // Calculate target position: keyboard top - 8px spacing
        const keyboardTop = SIZES.height - currentKeyboardHeight;
        const targetPosition = keyboardTop - 8;
        
        // Measure current position and calculate exact scroll needed
        inputRef.current?.measureInWindow((x, y, width, height) => {
          if (scrollViewRef.current) {
            // Calculate how much we need to scroll to position the input at targetPosition
            const currentScrollY = y;
            const scrollOffset = currentScrollY - targetPosition + height;
            
            // Scroll to the calculated position (only the amount needed)
            scrollViewRef.current.scrollTo({
              y: Math.max(0, scrollOffset),
              animated: true
            });
          }
        });
      } else {
        // Fallback: scroll to end if no keyboard height
        scrollViewRef.current?.scrollToEnd({ animated: true });
      }
    };
    
    // Execute with appropriate timing
    if (keyboardVisible) {
      performScroll();
    } else {
      // Wait for keyboard to appear, then scroll once
      setTimeout(performScroll, 50);
    }
  };



  // CI Color palette for diverse icons - using app's UI colors
  const iconColors = [
    COLORS.primary,      // Primary blue
    COLORS.success,      // Success green
    COLORS.warning,      // Warning orange
    COLORS.info,         // Info cyan
    COLORS.secondary,    // Secondary purple
    COLORS.tertiary,     // Tertiary pink
  ];

  // App UI colors for subtasks
  const subtaskColors = [
    COLORS.primary,      // Primary blue
    COLORS.success,      // Success green
    COLORS.warning,      // Warning orange
    COLORS.info,         // Info cyan
    COLORS.secondary,    // Secondary purple
    COLORS.tertiary,     // Tertiary pink
  ];

  // Show toast
  const showToast = (message: string, type: 'success' | 'error' | 'warning' | 'info' = 'success') => {
    setToast({ visible: true, message, type });
  };

  // Hide toast
  const hideToast = () => {
    setToast(prev => ({ ...prev, visible: false }));
  };

  // Check if all subtasks are completed
  const allSubtasksCompleted = useMemo(() => {
    return subtasks.length > 0 && subtasks.every(subtask => subtask.completed);
  }, [subtasks]);

  // Check if any subtasks are uncompleted (keeping for potential future use)
  const anySubtasksUncompleted = useMemo(() => {
    return subtasks.some(subtask => !subtask.completed);
  }, [subtasks]);

  // Auto-complete task when all subtasks are completed (but don't auto-uncomplete)
  useEffect(() => {
    if (task && subtasks.length > 0) {
      // Only auto-complete when ALL subtasks are completed
      if (allSubtasksCompleted && task.status !== 'completed') {
        handleAutoCompleteTask(true);
      }
      // Remove the auto-uncomplete logic to prevent tasks from being uncompleted
      // when switching to completed tab
    }
  }, [allSubtasksCompleted, task]);

  // Auto-complete task handler
  const handleAutoCompleteTask = async (complete: boolean) => {
    if (!task) return;
    
    try {
      const newStatus = complete ? 'completed' : 'in_progress';
      const updatedTask = await ProjectService.updateTask(task.id, { status: newStatus });
      if (updatedTask) {
        setTask(updatedTask);
        onTaskUpdate(task.id, { status: newStatus });
        
        // Update project progress after task change
        if (project) {
          await ProjectService.updateProjectProgress(project.id);
        }
        
        console.log(`âœ… Task auto-${complete ? 'completed' : 'uncompleted'} due to subtasks`);
      }
    } catch (error) {
      console.error('Error auto-updating task status:', error);
    }
  };

  // Animation functions
  const openModal = () => {
    console.log('ðŸ”µ TaskDetailsModal: openModal called');
    console.log('ðŸ”µ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸ”µ TaskDetailsModal: overlayOpacity value:', overlayOpacity);
    console.log('ðŸ”µ TaskDetailsModal: modalAnimation value:', modalAnimation);
    
    Animated.parallel([
      Animated.timing(overlayOpacity, {
        toValue: 1, // 100% opacity for all platforms
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(modalAnimation, {
        toValue: 1,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start(() => {
      console.log('ðŸ”µ TaskDetailsModal: Animation completed');
    });
  };

  const closeModal = () => {
    console.log('ðŸ”µ TaskDetailsModal: closeModal called');
    console.log('ðŸ”µ TaskDetailsModal: Platform:', Platform.OS);
    
    Animated.parallel([
      Animated.timing(overlayOpacity, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }),
      Animated.timing(modalAnimation, {
        toValue: 0,
        duration: 300,
        useNativeDriver: true,
      }),
    ]).start(() => {
      console.log('ðŸ”µ TaskDetailsModal: Close animation completed, calling onClose');
      onClose();
    });
  };

  // Handle modal visibility changes
  useEffect(() => {
    console.log('ðŸ”µ TaskDetailsModal: Modal visibility changed to:', visible);
    console.log('ðŸ”µ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸ”µ TaskDetailsModal: Current task:', task?.title);
    console.log('ðŸ”µ TaskDetailsModal: Current index:', currentIndex);
    
    if (visible) {
      console.log('ðŸ”µ TaskDetailsModal: Opening modal...');
      openModal();
    } else {
      console.log('ðŸ”µ TaskDetailsModal: Modal is now hidden');
    }
  }, [visible]);

  // Update currentIndex when currentTaskIndex prop changes
  useEffect(() => {
    setCurrentIndex(currentTaskIndex);
  }, [currentTaskIndex]);

  // Load task data when currentIndex changes
  useEffect(() => {
    if (tasks && tasks.length > 0 && currentIndex >= 0 && currentIndex < tasks.length) {
      const currentTask = tasks[currentIndex];
      setTask(currentTask);
      // Only load detailed data if modal is visible
      if (visible) {
        loadTaskData(currentTask.id);
      }
    }
  }, [currentIndex, tasks, visible]);

  // Ref to prevent multiple simultaneous data loads
  const loadingRef = useRef(false);

  // Load task data when modal opens or task changes
  const loadTaskData = async (taskId: string) => {
    // Prevent multiple simultaneous loads
    if (loadingRef.current) {
      console.log('TaskDetailsModal: Already loading data, skipping...');
      return;
    }
    
    try {
      loadingRef.current = true;
      setLoading(true);
      console.log('TaskDetailsModal: Loading task data for taskId:', taskId);
      
      const taskDetails = await ProjectService.getTaskDetails(taskId);
      console.log('TaskDetailsModal: Task data loaded:', taskDetails?.task?.title);
      
      if (taskDetails && taskDetails.task) {
        setTask(taskDetails.task);
        
        // Load subtasks
        setSubtasks(taskDetails.subtasks || []);
        
        // Load comments
        setComments(taskDetails.comments || []);
        
        // Load assigned users with enhanced error handling
        if (taskDetails.task.assigned_to && taskDetails.task.assigned_to.length > 0) {
          const { TeamService } = await import('@/utils/teamService');
          const users = await Promise.all(
            taskDetails.task.assigned_to.map(async (userId: string) => {
              try {
                const userData = await TeamService.getUserById(userId);
                return userData;
              } catch (error) {
                console.error('âŒ Error loading user data for assigned user:', userId, error);
                // Return a fallback user object instead of null
                return {
                  id: userId,
                  username: 'user',
                  full_name: 'User',
                  email: undefined,
                  avatar_url: undefined,
                  status: 'offline' as const,
                  last_seen: undefined,
                  verified: false
                };
              }
            })
          );
          // Filter out any null values and ensure we have valid user objects
          const validUsers = users.filter((u: any) => u !== null && u.id);
          setAssignedUsers(validUsers);
          console.log('âœ… Loaded assigned users:', validUsers.length);
        } else {
          setAssignedUsers([]);
        }
      }
    } catch (error) {
      console.error('Error loading task data:', error);
    } finally {
      setLoading(false);
      loadingRef.current = false;
    }
  };

  // Comprehensive keyboard handling for mobile platforms only
  useEffect(() => {
    // Only set up keyboard listeners on mobile platforms
    if (Platform.OS === 'web') return;

    const keyboardWillShowListener = Keyboard.addListener(
      Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow',
      (event) => {
        setKeyboardVisible(true);
        setKeyboardHeight(event.endCoordinates.height);
      }
    );

    const keyboardWillHideListener = Keyboard.addListener(
      Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide',
      () => {
        setKeyboardVisible(false);
        setKeyboardHeight(0);
      }
    );

    return () => {
      keyboardWillShowListener?.remove();
      keyboardWillHideListener?.remove();
    };
  }, []);

  // Navigation handlers
  const goToPreviousTask = () => {
    if (currentIndex > 0) {
      setCurrentIndex(currentIndex - 1);
    }
  };

  const goToNextTask = () => {
    if (tasks && currentIndex < tasks.length - 1) {
      setCurrentIndex(currentIndex + 1);
    }
  };

  // Task update handlers
  const handleTaskUpdate = async (field: string, value: any) => {
    if (!task) return;
    
    try {
      const updatedTask = await ProjectService.updateTask(task.id, { [field]: value });
      if (updatedTask) {
        setTask(updatedTask);
        onTaskUpdate(task.id, { [field]: value });
        
        // Update project progress after task change
        if (project) {
          await ProjectService.updateProjectProgress(project.id);
        }
      } else {
        Alert.alert('Error', 'Failed to update task');
      }
    } catch (error) {
      console.error('Error updating task:', error);
      Alert.alert('Error', 'Failed to update task');
    }
  };

  // Subtask handlers
  const handleSubtaskToggle = async (subtaskId: string, completed: boolean) => {
    // Optimistic update - update UI immediately
    setSubtasks(prev => prev.map(subtask => 
      subtask.id === subtaskId ? { ...subtask, completed } : subtask
    ));

    try {
      // Update in background
      await ProjectService.updateSubtask(subtaskId, {
        status: completed ? 'completed' : 'todo',
        completed_at: completed ? new Date().toISOString() : undefined
      });
    } catch (error) {
      console.error('Error updating subtask:', error);
      // Revert on error
      setSubtasks(prev => prev.map(subtask => 
        subtask.id === subtaskId ? { ...subtask, completed: !completed } : subtask
      ));
      Alert.alert('Error', 'Failed to update subtask');
    }
  };

  // Sort subtasks with completed items at the bottom (iOS Notes style)
  const sortedSubtasks = useMemo(() => {
    return [...subtasks].sort((a, b) => {
      // If both have same completion status, maintain original order
      if (a.completed === b.completed) {
        return a.order_index - b.order_index;
      }
      // Uncompleted items first, completed items last
      return a.completed ? 1 : -1;
    });
  }, [subtasks]);

  const handleSubtaskReorder = async (fromIndex: number, toIndex: number) => {
    const newSubtasks = [...subtasks];
    const [movedSubtask] = newSubtasks.splice(fromIndex, 1);
    newSubtasks.splice(toIndex, 0, movedSubtask);
    
    // Update order_index for all subtasks
    const updatedSubtasks = newSubtasks.map((subtask, index) => ({
      ...subtask,
      order_index: index
    }));
    
    setSubtasks(updatedSubtasks);
    
    try {
      // Update order_index in database for all subtasks
      const updatePromises = updatedSubtasks.map(subtask =>
        ProjectService.updateSubtask(subtask.id, { order_index: subtask.order_index })
      );
      await Promise.all(updatePromises);
    } catch (error) {
      console.error('Error reordering subtasks:', error);
      // Revert on error
      setSubtasks(subtasks);
      Alert.alert('Error', 'Failed to reorder subtasks');
    }
  };

  const handleSubtaskUpdate = async (subtaskId: string, updates: any) => {
    try {
      const updatedSubtask = await ProjectService.updateSubtask(subtaskId, updates);
      if (updatedSubtask) {
        setSubtasks(prev => prev.map(subtask => 
          subtask.id === subtaskId ? { ...subtask, ...updates } : subtask
        ));
        console.log('âœ… Subtask updated:', subtaskId, updates);
      } else {
        Alert.alert('Error', 'Failed to update subtask');
      }
    } catch (error) {
      console.error('Error updating subtask:', error);
      Alert.alert('Error', 'Failed to update subtask');
    }
  };

  const handleAddSubtasks = async () => {
    if (!newSubtaskText.trim() || !task) return;

    // Split by commas and handle both single and multiple entries
    const subtaskTitles = newSubtaskText
      .split(',')
      .map(title => title.trim())
      .filter(title => title.length > 0);

    if (subtaskTitles.length === 0) return;

    setNewSubtaskText('');
    setShowSubtaskInput(false);

    try {
      // Create subtasks in background with real IDs
      const newSubtasks: any[] = [];
      for (const title of subtaskTitles) {
        const createdSubtask = await ProjectService.createSubtask({
          task_id: task.id,
          title: title,
          status: 'todo' as const,
          priority: 'medium' as const,
          assigned_to: task.assigned_to && task.assigned_to.length > 0 ? task.assigned_to[0] : undefined,
          order_index: subtasks.length + newSubtasks.length,
        });
        
        if (createdSubtask) {
          newSubtasks.push(createdSubtask);
        }
      }
      
      // Add the newly created subtasks to the UI
      setSubtasks(prev => [...prev, ...newSubtasks]);
      
      console.log('âœ… Subtasks created successfully');
    } catch (error) {
      console.error('Error creating subtasks:', error);
      Alert.alert('Error', 'Failed to create subtasks');
    }
  };

  const handleSubtaskDelete = async (subtaskId: string) => {
    Alert.alert(
      'Delete Subtask',
      'Are you sure you want to delete this subtask?',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              const success = await ProjectService.deleteSubtask(subtaskId);
              if (success) {
                setSubtasks(prev => prev.filter(s => s.id !== subtaskId));
                console.log('âœ… Subtask deleted:', subtaskId);
              } else {
                Alert.alert('Error', 'Failed to delete subtask');
              }
            } catch (error) {
              console.error('Error deleting subtask:', error);
              Alert.alert('Error', 'Failed to delete subtask');
            }
          }
        }
      ]
    );
  };

  // Comment handlers
  const handlePostComment = async () => {
    if (!task || !newComment.trim() || isPostingComment || !user) return;
    
    try {
      setIsPostingComment(true);
      const comment = await ProjectService.createTaskComment({
        task_id: task.id,
        user_id: user?.id || '',
        content: newComment.trim()
      });
      
      if (comment) {
        // Add user data to the comment immediately
        const commentWithUser = {
          ...comment,
          user: {
            id: user.id,
            full_name: user.user_metadata?.full_name || user.email || 'Current User',
            avatar_url: user.user_metadata?.avatar_url || null
          }
        };
        setComments(prev => [commentWithUser, ...prev]);
        setNewComment('');
        console.log('âœ… Comment posted successfully');
      } else {
        Alert.alert('Error', 'Failed to post comment');
      }
    } catch (error) {
      console.error('Error posting comment:', error);
      Alert.alert('Error', 'Failed to post comment');
    } finally {
      setIsPostingComment(false);
    }
  };

  // Show delete confirmation modal
  const showDeleteConfirmationModal = () => {
    console.log('ðŸ”´ TaskDetailsModal: showDeleteConfirmationModal called');
    console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸ”´ TaskDetailsModal: Current showDeleteConfirmation state:', showDeleteConfirmation);
    console.log('ðŸ”´ TaskDetailsModal: Task exists:', !!task);
    console.log('ðŸ”´ TaskDetailsModal: Task title:', task?.title);
    console.log('ðŸ”´ TaskDetailsModal: Task ID:', task?.id);
    
    // Set state immediately and log it
    setShowDeleteConfirmation(true);
    console.log('ðŸ”´ TaskDetailsModal: Setting showDeleteConfirmation to true');
    console.log('ðŸ”´ TaskDetailsModal: Delete confirmation modal should now be visible');
    
    // Log after state update
    setTimeout(() => {
      console.log('ðŸ”´ TaskDetailsModal: After state update - showDeleteConfirmation:', true);
    }, 0);
  };

  // Hide delete confirmation modal
  const hideDeleteConfirmationModal = () => {
    console.log('ðŸ”´ TaskDetailsModal: hideDeleteConfirmationModal called');
    console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸ”´ TaskDetailsModal: Current showDeleteConfirmation state:', showDeleteConfirmation);
    console.log('ðŸ”´ TaskDetailsModal: Current isDeleting state:', isDeleting);
    
    setShowDeleteConfirmation(false);
    setIsDeleting(false);
    console.log('ðŸ”´ TaskDetailsModal: Setting showDeleteConfirmation to false');
    console.log('ðŸ”´ TaskDetailsModal: Setting isDeleting to false');
    console.log('ðŸ”´ TaskDetailsModal: Delete confirmation modal should now be hidden');
    
    // Log after state update
    setTimeout(() => {
      console.log('ðŸ”´ TaskDetailsModal: After state update - showDeleteConfirmation:', false);
    }, 0);
  };

  // Delete task handler with confirmation and toast
  const handleDeleteTask = () => {
    console.log('ðŸ”´ TaskDetailsModal: Delete button pressed for task:', task?.id);
    console.log('ðŸ”´ TaskDetailsModal: Task exists:', !!task);
    console.log('ðŸ”´ TaskDetailsModal: Task title:', task?.title);
    console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸ”´ TaskDetailsModal: Current showDeleteConfirmation state:', showDeleteConfirmation);
    console.log('ðŸ”´ TaskDetailsModal: Current isDeleting state:', isDeleting);
    
    if (!task) {
      console.log('ðŸ”´ TaskDetailsModal: No task to delete');
      return;
    }
    
    console.log('ðŸ”´ TaskDetailsModal: Showing custom delete confirmation modal');
    showDeleteConfirmationModal();
  };

  // Execute task deletion
  const executeTaskDeletion = async () => {
    console.log('ðŸ”´ TaskDetailsModal: executeTaskDeletion called');
    console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸ”´ TaskDetailsModal: Task exists:', !!task);
    console.log('ðŸ”´ TaskDetailsModal: Task ID:', task?.id);
    console.log('ðŸ”´ TaskDetailsModal: Current isDeleting state:', isDeleting);
    
    if (!task) {
      console.log('ðŸ”´ TaskDetailsModal: No task to delete, returning');
      return;
    }
    
    try {
      console.log('ðŸ”´ TaskDetailsModal: Setting isDeleting to true');
      setIsDeleting(true);
      console.log('ðŸ”´ TaskDetailsModal: Calling ProjectService.deleteTask with task ID:', task.id);
      const success = await ProjectService.deleteTask(task.id);
      console.log('ðŸ”´ TaskDetailsModal: ProjectService.deleteTask result:', success);
      
      if (success) {
        console.log('ðŸ”´ TaskDetailsModal: Task deletion successful, showing toast');
        showToast('Task deleted successfully!', 'success');
        console.log('ðŸ”´ TaskDetailsModal: Calling onTaskDelete with task ID:', task.id);
        onTaskDelete(task.id);
        console.log('ðŸ”´ TaskDetailsModal: Hiding delete confirmation modal');
        hideDeleteConfirmationModal();
        console.log('ðŸ”´ TaskDetailsModal: Closing main modal');
        closeModal();
        console.log('âœ… Task deleted:', task.id);
      } else {
        console.log('ðŸ”´ TaskDetailsModal: Task deletion failed, showing error toast');
        showToast('Failed to delete task', 'error');
        console.log('ðŸ”´ TaskDetailsModal: Setting isDeleting to false');
        setIsDeleting(false);
      }
    } catch (error) {
      console.error('ðŸ”´ TaskDetailsModal: Error deleting task:', error);
      showToast('Error deleting task', 'error');
      setIsDeleting(false);
    }
  };

  // Edit handlers
  const startEditing = (field: string, currentValue: string) => {
    setEditingField(field);
    setEditValue(currentValue);
  };

  const saveEdit = async () => {
    if (!task || !editingField) return;
    
    await handleTaskUpdate(editingField, editValue);
    setEditingField(null);
    setEditValue('');
  };

  const cancelEdit = () => {
    setEditingField(null);
    setEditValue('');
  };

  const handleTaskCompleteToggle = async () => {
    if (!task) return;
    
    const newStatus = task.status === 'completed' ? 'in_progress' : 'completed';
    
    try {
      const updatedTask = await ProjectService.updateTask(task.id, { status: newStatus });
      if (updatedTask) {
        setTask(updatedTask);
        onTaskUpdate(task.id, { status: newStatus });
        
        // If marking as completed, also mark all subtasks as completed
        if (newStatus === 'completed') {
          await handleCompleteAllSubtasks();
        }
        
        // Update project progress after task change
        if (project) {
          await ProjectService.updateProjectProgress(project.id);
        }
      } else {
        Alert.alert('Error', 'Failed to update task');
      }
    } catch (error) {
      console.error('Error updating task:', error);
      Alert.alert('Error', 'Failed to update task');
    }
  };

  const handleCompleteAllSubtasks = async () => {
    if (!task || subtasks.length === 0) return;
    
    // Optimistic update - mark all subtasks as completed immediately
    setSubtasks(prev => prev.map(subtask => ({ ...subtask, completed: true })));
    
    try {
      // Update all subtasks in background
      const updatePromises = subtasks.map(subtask => 
        ProjectService.updateSubtask(subtask.id, {
          status: 'completed' as const,
          completed_at: new Date().toISOString()
        })
      );
      await Promise.all(updatePromises);
      
      console.log('âœ… All subtasks marked as completed');
    } catch (error) {
      console.error('Error completing all subtasks:', error);
      // Revert on error
      setSubtasks(prev => prev.map(subtask => ({ ...subtask, completed: false })));
      Alert.alert('Error', 'Failed to complete all subtasks');
    }
  };

  // Handle task reassignment
  const handleTaskReassign = async (newAssignees: string[]) => {
    console.log('ðŸŸ¡ TaskDetailsModal: handleTaskReassign called');
    console.log('ðŸŸ¡ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸŸ¡ TaskDetailsModal: Task exists:', !!task);
    console.log('ðŸŸ¡ TaskDetailsModal: Task ID:', task?.id);
    console.log('ðŸŸ¡ TaskDetailsModal: New assignees:', newAssignees);
    console.log('ðŸŸ¡ TaskDetailsModal: Current showReassignmentModal state:', showReassignmentModal);
    
    if (!task) {
      console.log('ðŸŸ¡ TaskDetailsModal: No task to reassign, returning');
      return;
    }
    
    try {
      console.log('ðŸŸ¡ TaskDetailsModal: Calling ProjectService.updateTask with new assignees');
      const updatedTask = await ProjectService.updateTask(task.id, {
        assigned_to: newAssignees // Use the full array of assignees
      });
      console.log('ðŸŸ¡ TaskDetailsModal: ProjectService.updateTask result:', !!updatedTask);
      
      if (updatedTask) {
        console.log('ðŸŸ¡ TaskDetailsModal: Task updated successfully, updating local state');
        setTask(updatedTask);
        
        // Trigger a global refresh by calling onTaskUpdate with 'refresh' field
        // This will notify all parent components to refresh their task lists
        console.log('ðŸŸ¡ TaskDetailsModal: Calling onTaskUpdate with refresh trigger');
        onTaskUpdate(task.id, { 
          assigned_to: newAssignees,
          _refreshTrigger: true // Special flag to trigger refresh
        });
        
        // Reload assigned users
        if (newAssignees.length > 0) {
          console.log('ðŸŸ¡ TaskDetailsModal: Reloading assigned users for new assignees');
          const { TeamService } = await import('@/utils/teamService');
          const users = await Promise.all(
            newAssignees.map(userId => TeamService.getUserById(userId))
          );
          const validUsers = users.filter(u => u !== null);
          console.log('ðŸŸ¡ TaskDetailsModal: Loaded valid users:', validUsers.length);
          setAssignedUsers(validUsers);
        } else {
          console.log('ðŸŸ¡ TaskDetailsModal: No new assignees, clearing assigned users');
          setAssignedUsers([]);
        }
        
        console.log('ðŸŸ¡ TaskDetailsModal: Showing success toast');
        showToast('Task reassigned successfully!', 'success');
        
        // Close the reassignment modal
        console.log('ðŸŸ¡ TaskDetailsModal: Closing reassignment modal');
        setShowReassignmentModal(false);
      } else {
        console.log('ðŸŸ¡ TaskDetailsModal: Task update failed');
      }
    } catch (error) {
      console.error('ðŸŸ¡ TaskDetailsModal: Error reassigning task:', error);
      showToast('Failed to reassign task', 'error');
    }
  };

  // Debug modal state changes
  useEffect(() => {
    console.log('ðŸŸ¡ TaskDetailsModal: showReassignmentModal changed to:', showReassignmentModal);
    console.log('ðŸŸ¡ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸŸ¡ TaskDetailsModal: Project data:', {
      projectId: project?.id,
      projectName: project?.name,
      projectExists: !!project
    });
    console.log('ðŸŸ¡ TaskDetailsModal: Task data:', {
      taskId: task?.id,
      taskTitle: task?.title,
      taskExists: !!task
    });
  }, [showReassignmentModal, project, task]);

  // Debug delete confirmation modal state changes
  useEffect(() => {
    console.log('ðŸ”´ TaskDetailsModal: showDeleteConfirmation changed to:', showDeleteConfirmation);
    console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸ”´ TaskDetailsModal: Task data for delete:', {
      taskId: task?.id,
      taskTitle: task?.title,
      taskExists: !!task
    });
    console.log('ðŸ”´ TaskDetailsModal: Modal should be visible:', showDeleteConfirmation);
    console.log('ðŸ”´ TaskDetailsModal: Current isDeleting state:', isDeleting);
  }, [showDeleteConfirmation, task, isDeleting]);

  // Cleanup reassignment modal when main modal closes
  useEffect(() => {
    console.log('ðŸŸ¡ TaskDetailsModal: Cleanup effect - visible:', visible, 'showReassignmentModal:', showReassignmentModal);
    console.log('ðŸŸ¡ TaskDetailsModal: Platform:', Platform.OS);
    
    if (!visible && showReassignmentModal) {
      console.log('ðŸŸ¡ TaskDetailsModal: Main modal closing, cleaning up reassignment modal');
      setShowReassignmentModal(false);
    }
  }, [visible, showReassignmentModal]);

  // Cleanup delete confirmation modal when main modal closes
  useEffect(() => {
    console.log('ðŸ”´ TaskDetailsModal: Cleanup effect - visible:', visible, 'showDeleteConfirmation:', showDeleteConfirmation);
    console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
    
    if (!visible && showDeleteConfirmation) {
      console.log('ðŸ”´ TaskDetailsModal: Main modal closing, cleaning up delete confirmation modal');
      setShowDeleteConfirmation(false);
      setIsDeleting(false);
    }
  }, [visible, showDeleteConfirmation]);

  // Debug date picker modal state changes
  useEffect(() => {
    console.log('ðŸŸ¢ TaskDetailsModal: showDatePicker changed to:', showDatePicker);
    console.log('ðŸŸ¢ TaskDetailsModal: Platform:', Platform.OS);
    console.log('ðŸŸ¢ TaskDetailsModal: Task exists:', !!task);
    console.log('ðŸŸ¢ TaskDetailsModal: Task due_date:', task?.due_date);
  }, [showDatePicker, task]);

  // Cleanup date picker modal when main modal closes
  useEffect(() => {
    console.log('ðŸŸ¢ TaskDetailsModal: Cleanup effect - visible:', visible, 'showDatePicker:', showDatePicker);
    console.log('ðŸŸ¢ TaskDetailsModal: Platform:', Platform.OS);
    
    if (!visible && showDatePicker) {
      console.log('ðŸŸ¢ TaskDetailsModal: Main modal closing, cleaning up date picker modal');
      setShowDatePicker(false);
    }
  }, [visible, showDatePicker]);

  if (!task) return null;

  // Comprehensive state logging on every render
  console.log('ðŸ”µ TaskDetailsModal: === RENDER SUMMARY ===');
  console.log('ðŸ”µ TaskDetailsModal: Platform:', Platform.OS);
  console.log('ðŸ”µ TaskDetailsModal: visible prop:', visible);
  console.log('ðŸ”µ TaskDetailsModal: task exists:', !!task);
  console.log('ðŸ”µ TaskDetailsModal: task title:', task?.title);
  console.log('ðŸ”µ TaskDetailsModal: task ID:', task?.id);
  console.log('ðŸ”µ TaskDetailsModal: showDatePicker:', showDatePicker);
  console.log('ðŸ”µ TaskDetailsModal: showDeleteConfirmation:', showDeleteConfirmation);
  console.log('ðŸ”µ TaskDetailsModal: showReassignmentModal:', showReassignmentModal);
  console.log('ðŸ”µ TaskDetailsModal: isDeleting:', isDeleting);
  console.log('ðŸ”µ TaskDetailsModal: currentIndex:', currentIndex);
  console.log('ðŸ”µ TaskDetailsModal: === END RENDER SUMMARY ===');

  return (
    <>
      <Modal
        visible={visible}
        transparent
        animationType="none"
        onRequestClose={() => {
          console.log('ðŸ”µ TaskDetailsModal: Main modal onRequestClose called');
          console.log('ðŸ”µ TaskDetailsModal: Platform:', Platform.OS);
          closeModal();
        }}
        presentationStyle="overFullScreen"
        statusBarTranslucent={true}
        hardwareAccelerated={true}
        style={{ zIndex: 1000 }}
        onShow={() => {
          console.log('ðŸ”µ TaskDetailsModal: Main modal onShow called');
          console.log('ðŸ”µ TaskDetailsModal: Platform:', Platform.OS);
        }}
        onDismiss={() => {
          console.log('ðŸ”µ TaskDetailsModal: Main modal onDismiss called');
          console.log('ðŸ”µ TaskDetailsModal: Platform:', Platform.OS);
        }}
      >
        <Animated.View style={[styles.overlay, { opacity: overlayOpacity }]}>
          <TouchableOpacity
            style={styles.overlayTouchable}
            onPress={closeModal}
            activeOpacity={1}
          />
            <Animated.View
              style={[
                styles.modalContainer,
                {
                  transform: [
                    {
                      translateY: modalAnimation.interpolate({
                        inputRange: [0, 1],
                        outputRange: [SIZES.height, 0],
                      }),
                    },
                  ],
                  height: '90%',
                },
              ]}
            >
            {/* Drag Handle */}
            <View style={styles.dragHandle}>
              <View style={[styles.dragIndicator, {
                backgroundColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
              }]} />
            </View>

            {/* Header */}
            <View style={styles.header}>
              <View style={styles.headerLeft}>
                <TouchableOpacity
                  onPress={handleTaskCompleteToggle}
                  style={[styles.titleIcon, { 
                    backgroundColor: task?.status === 'completed' 
                      ? iconColors[1] + '20' 
                      : iconColors[0] + '20' 
                  }]}
                  activeOpacity={0.7}
                >
                  <Ionicons 
                    name={task?.status === 'completed' ? "checkmark-circle" : "list"} 
                    size={20} 
                    color={task?.status === 'completed' ? iconColors[1] : iconColors[0]} 
                  />
                </TouchableOpacity>
                <TouchableOpacity
                  onLongPress={() => startEditing('title', task.title)}
                  style={styles.titleContainer}
                  activeOpacity={0.7}
                >
                  <Text style={[styles.title, {
                    color: dark ? COLORS.white : COLORS.greyscale900,
                    textDecorationLine: task?.status === 'completed' ? 'line-through' : 'none',
                    opacity: task?.status === 'completed' ? 0.6 : 1,
                  }]}>
                    {task.title}
                  </Text>
                  <Text style={[styles.editHint, {
                    color: dark ? COLORS.grayscale400 : COLORS.grayscale700,
                  }]}>
                    Long press to edit
                  </Text>
                </TouchableOpacity>
              </View>
              <View style={styles.headerRight}>
                <TouchableOpacity 
                  onPress={() => {
                    console.log('ðŸ”´ TaskDetailsModal: Delete button TouchableOpacity pressed');
                    console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
                    console.log('ðŸ”´ TaskDetailsModal: Current showDeleteConfirmation state:', showDeleteConfirmation);
                    console.log('ðŸ”´ TaskDetailsModal: Current isDeleting state:', isDeleting);
                    handleDeleteTask();
                  }} 
                  style={styles.deleteButton}
                  activeOpacity={0.6}
                  hitSlop={{ top: 15, bottom: 15, left: 15, right: 15 }}
                  accessibilityLabel="Delete Task"
                  accessibilityRole="button"
                  accessibilityHint="Double tap to delete this task"
                >
                  <Ionicons 
                    name="trash-outline" 
                    size={24} 
                    color={COLORS.error} 
                  />
                </TouchableOpacity>
                <TouchableOpacity onPress={closeModal} style={styles.closeButton}>
                  <Ionicons 
                    name="close-circle" 
                    size={28} 
                    color={dark ? COLORS.grayscale400 : COLORS.grayscale700} 
                  />
                </TouchableOpacity>
              </View>
            </View>

            {/* Navigation */}
            <View style={styles.navigationContainer}>
              <TouchableOpacity
                onPress={goToPreviousTask}
                disabled={currentIndex === 0}
                style={[styles.navButton, {
                  opacity: currentIndex === 0 ? 0.5 : 1,
                }]}
              >
                <Ionicons 
                  name="chevron-back" 
                  size={20} 
                  color={dark ? COLORS.white : COLORS.greyscale900} 
                />
              </TouchableOpacity>
              
              <Text style={[styles.navigationTitle, {
                color: dark ? COLORS.white : COLORS.greyscale900,
              }]}>
                {currentIndex + 1} of {tasks?.length || 0}
              </Text>
              
              <TouchableOpacity
                onPress={goToNextTask}
                disabled={!tasks || currentIndex === tasks.length - 1}
                style={[styles.navButton, {
                  opacity: !tasks || currentIndex === tasks.length - 1 ? 0.5 : 1,
                }]}
              >
                <Ionicons 
                  name="chevron-forward" 
                  size={20} 
                  color={dark ? COLORS.white : COLORS.greyscale900} 
                />
              </TouchableOpacity>
            </View>

            {/* Form Content */}
            <ScrollView 
              style={styles.content}
              showsVerticalScrollIndicator={true}
              keyboardShouldPersistTaps="handled"
              keyboardDismissMode="on-drag"
              contentContainerStyle={[
                styles.contentContainer,
                {
                  paddingBottom: keyboardVisible ? keyboardHeight + 200 : 100,
                  paddingTop: keyboardVisible ? 50 : 0,
                }
              ]}
              nestedScrollEnabled={true}
              ref={scrollViewRef}
            >
              {loading ? (
                <View style={styles.loadingContainer}>
                  <ActivityIndicator size="large" color={COLORS.primary} />
                  <Text style={[styles.loadingText, {
                    color: dark ? COLORS.white : COLORS.greyscale900,
                  }]}>
                    Loading task details...
                  </Text>
                </View>
              ) : (
                <>
                  
                  {/* Task Description */}
                  <View style={styles.inputSection}>
                    <View style={styles.labelContainer}>
                      <Ionicons name="chatbubble-ellipses" size={18} color={iconColors[2]} />
                      <Text style={[styles.label, {
                        color: dark ? COLORS.white : COLORS.greyscale900,
                      }]}>
                        Description
                      </Text>
                    </View>
                    {editingField === 'description' ? (
                      <View style={styles.editContainer}>
                        <TextInput
                          ref={descriptionInputRef}
                          style={[styles.textArea, {
                            color: dark ? COLORS.white : COLORS.greyscale900,
                            backgroundColor: dark ? COLORS.dark3 : COLORS.grayscale100,
                            borderColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                          }]}
                          placeholder="Enter task description..."
                          placeholderTextColor={dark ? COLORS.grayscale400 : COLORS.grayscale700}
                          value={editValue}
                          onChangeText={setEditValue}
                          multiline
                          numberOfLines={4}
                          textAlignVertical="top"
                          onFocus={() => {
                            // Scroll to description input when focused (mobile only)
                            if (Platform.OS !== 'web') {
                              setTimeout(() => {
                                scrollToInputField(descriptionInputRef, 'description');
                              }, 100);
                            }
                          }}
                        />
                        <View style={styles.editActions}>
                          <TouchableOpacity onPress={cancelEdit} style={styles.cancelEditButton}>
                            <Text style={[styles.cancelEditText, { color: COLORS.error }]}>Cancel</Text>
                          </TouchableOpacity>
                          <TouchableOpacity onPress={saveEdit} style={styles.saveEditButton}>
                            <Text style={[styles.saveEditText, { color: COLORS.primary }]}>Save</Text>
                          </TouchableOpacity>
                        </View>
                      </View>
                    ) : (
                      <TouchableOpacity
                        onLongPress={() => startEditing('description', task.description || '')}
                        style={[styles.descriptionContainer, {
                          backgroundColor: dark ? COLORS.dark3 : COLORS.grayscale100,
                          borderColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                        }]}
                        activeOpacity={0.7}
                      >
                        <Text style={[styles.descriptionText, {
                          color: dark ? COLORS.white : COLORS.greyscale900,
                        }]}>
                          {task.description || 'No description'}
                        </Text>
                        <Text style={[styles.editHint, {
                          color: dark ? COLORS.grayscale400 : COLORS.grayscale700,
                        }]}>
                          Long press to edit
                        </Text>
                      </TouchableOpacity>
                    )}
                  </View>

                  {/* Due Date */}
                  <View style={styles.inputSection}>
                    <View style={styles.labelContainer}>
                      <Ionicons name="calendar" size={16} color={iconColors[3]} />
                      <Text style={[styles.label, {
                        color: dark ? COLORS.white : COLORS.greyscale900,
                      }]}>
                        Due Date
                      </Text>
                    </View>
                    <TouchableOpacity
                      style={[styles.dateButton, {
                        backgroundColor: dark ? COLORS.dark3 : COLORS.grayscale100,
                        borderColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                      }]}
                      onPress={() => {
                        console.log('ðŸŸ¢ TaskDetailsModal: Date picker button pressed');
                        console.log('ðŸŸ¢ TaskDetailsModal: Platform:', Platform.OS);
                        console.log('ðŸŸ¢ TaskDetailsModal: Current showDatePicker state:', showDatePicker);
                        console.log('ðŸŸ¢ TaskDetailsModal: Setting showDatePicker to true');
                        setShowDatePicker(true);
                        console.log('ðŸŸ¢ TaskDetailsModal: showDatePicker should now be true');
                        
                        // Log after state update
                        setTimeout(() => {
                          console.log('ðŸŸ¢ TaskDetailsModal: After state update - showDatePicker:', true);
                        }, 0);
                      }}
                    >
                      <Text style={[styles.dateText, {
                        color: dark ? COLORS.white : COLORS.greyscale900,
                      }]}>
                        {task.due_date ? task.due_date : 'No due date'}
                      </Text>
                      <Ionicons 
                        name="calendar-outline" 
                        size={20} 
                        color={iconColors[3]} 
                      />
                    </TouchableOpacity>
                  </View>

                  {/* Assigned Users */}
                  <View style={styles.inputSection}>
                    <View style={styles.labelContainer}>
                      <Ionicons name="people" size={18} color={iconColors[4]} />
                      <Text style={[styles.label, {
                        color: dark ? COLORS.white : COLORS.greyscale900,
                      }]}>
                        Assigned To
                      </Text>
                      <TouchableOpacity
                        onPress={() => {
                          console.log('ðŸŸ¡ TaskDetailsModal: Reassign button pressed for task:', task?.id);
                          console.log('ðŸŸ¡ TaskDetailsModal: Platform:', Platform.OS);
                          console.log('ðŸŸ¡ TaskDetailsModal: Project ID:', project?.id);
                          console.log('ðŸŸ¡ TaskDetailsModal: Current showReassignmentModal state:', showReassignmentModal);
                          console.log('ðŸŸ¡ TaskDetailsModal: Setting showReassignmentModal to true');
                          setShowReassignmentModal(true);
                          console.log('ðŸŸ¡ TaskDetailsModal: showReassignmentModal should now be true');
                          
                          // Log after state update
                          setTimeout(() => {
                            console.log('ðŸŸ¡ TaskDetailsModal: After state update - showReassignmentModal:', true);
                          }, 0);
                        }}
                        style={styles.reassignButton}
                        activeOpacity={0.7}
                        hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                        accessibilityLabel="Reassign Task"
                        accessibilityRole="button"
                      >
                        <Ionicons 
                          name="swap-horizontal" 
                          size={16} 
                          color={iconColors[4]} 
                        />
                        <Text style={[styles.reassignButtonText, { color: iconColors[4] }]}>
                          Reassign
                        </Text>
                      </TouchableOpacity>
                    </View>
                    
                    {assignedUsers.length > 0 ? (
                      <View style={styles.assignedUsersContainer}>
                        {assignedUsers.map((user, index) => (
                          <View key={user.id || index} style={styles.assignedUserItem}>
                            <UserAvatar 
                              userId={user.id}
                              size={32}
                            />
                            <Text style={[styles.assignedUserName, {
                              color: dark ? COLORS.white : COLORS.greyscale900,
                            }]}>
                              {user.full_name || user.user_name || 'Fetching name...'}
                            </Text>
                          </View>
                        ))}
                      </View>
                    ) : (
                      <View style={[styles.noAssigneesContainer, {
                        backgroundColor: dark ? COLORS.dark3 : COLORS.grayscale100,
                        borderColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                      }]}>
                        <Ionicons name="people-outline" size={20} color={dark ? COLORS.grayscale400 : COLORS.grayscale700} />
                        <Text style={[styles.noAssigneesText, {
                          color: dark ? COLORS.grayscale400 : COLORS.grayscale700,
                        }]}>
                          No one assigned
                        </Text>
                      </View>
                    )}
                  </View>

                  {/* Subtasks Section */}
                  <View style={styles.inputSection}>
                    <View style={styles.labelContainer}>
                      <Ionicons name="list" size={18} color={iconColors[4]} />
                      <Text style={[styles.label, {
                        color: dark ? COLORS.white : COLORS.greyscale900,
                      }]}>
                        Subtasks ({subtasks.length})
                      </Text>
                      <TouchableOpacity
                        onPress={() => setShowSubtaskInput(!showSubtaskInput)}
                        style={styles.addSubtaskButton}
                      >
                        <Ionicons 
                          name={showSubtaskInput ? "remove" : "add"} 
                          size={20} 
                          color={iconColors[4]} 
                        />
                      </TouchableOpacity>
                    </View>

                    {/* Progress Bar */}
                    {subtasks.length > 0 && (
                      <View style={styles.progressContainer}>
                        <View style={[styles.progressBar, {
                          backgroundColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                        }]}>
                          <View 
                            style={[
                              styles.progressFill, 
                              { 
                                width: `${(subtasks.filter(s => s.completed).length / subtasks.length) * 100}%`,
                                backgroundColor: iconColors[1],
                              }
                            ]} 
                          />
                        </View>
                        <Text style={[styles.progressText, {
                          color: dark ? COLORS.white : COLORS.greyscale900,
                        }]}>
                          {subtasks.filter(s => s.completed).length}/{subtasks.length}
                        </Text>
                      </View>
                    )}

                    {/* Add Subtask Input */}
                    {showSubtaskInput && (
                      <View style={styles.subtaskInputContainer}>
                        <TextInput
                          ref={subtaskInputRef}
                          style={[styles.subtaskInput, {
                            color: dark ? COLORS.white : COLORS.greyscale900,
                            backgroundColor: dark ? COLORS.dark3 : COLORS.grayscale100,
                            borderColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                          }]}
                          placeholder="Add subtask (comma-separated for multiple)"
                          placeholderTextColor={dark ? COLORS.grayscale400 : COLORS.grayscale700}
                          value={newSubtaskText}
                          onChangeText={setNewSubtaskText}
                          multiline
                          numberOfLines={2}
                          onSubmitEditing={handleAddSubtasks}
                          onKeyPress={(e) => {
                            if (e.nativeEvent.key === 'Enter') {
                              handleAddSubtasks();
                            }
                          }}
                          onFocus={() => {
                            // Scroll to input when focused (mobile only)
                            if (Platform.OS !== 'web') {
                              setTimeout(() => {
                                scrollToInputField(subtaskInputRef, 'subtask');
                              }, 100);
                            }
                          }}
                          returnKeyType="done"
                          blurOnSubmit={false}
                        />
                        <TouchableOpacity
                          onPress={handleAddSubtasks}
                          style={[styles.addSubtaskActionButton, {
                            backgroundColor: iconColors[3],
                          }]}
                        >
                          <Ionicons name="add" size={20} color={COLORS.white} />
                        </TouchableOpacity>
                      </View>
                    )}

                    {/* Subtasks List */}
                    <View style={styles.subtasksList}>
                      <FlatList
                        data={sortedSubtasks}
                        keyExtractor={(item) => item.id}
                        renderItem={({ item: subtask, index }) => (
                          <SubtaskCard
                            subtask={subtask}
                            onToggle={handleSubtaskToggle}
                            onUpdate={handleSubtaskUpdate}
                            onDelete={handleSubtaskDelete}
                            onReorder={handleSubtaskReorder}
                            index={index}
                            totalSubtasks={subtasks.length}
                          />
                        )}
                        scrollEnabled={false}
                        showsVerticalScrollIndicator={false}
                      />
                    </View>
                  </View>

                  {/* Comments Section */}
                  <View style={styles.inputSection}>
                    <View style={styles.labelContainer}>
                      <Ionicons name="chatbubbles" size={18} color={iconColors[5]} />
                      <Text style={[styles.label, {
                        color: dark ? COLORS.white : COLORS.greyscale900,
                      }]}>
                        Comments ({comments.length})
                      </Text>
                    </View>
                    
                    {/* Add Comment */}
                    <View style={styles.commentInputContainer}>
                      <UserAvatar
                        size={32}
                        style={styles.commentInputAvatar}
                      />
                      <View style={styles.commentInputSection}>
                        <TextInput
                          ref={commentInputRef}
                          style={[styles.commentInput, {
                            color: dark ? COLORS.white : COLORS.greyscale900,
                            backgroundColor: dark ? COLORS.dark3 : COLORS.grayscale100,
                            borderColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                          }]}
                          placeholder="Add a comment..."
                          placeholderTextColor={dark ? COLORS.grayscale400 : COLORS.grayscale700}
                          value={newComment}
                          onChangeText={setNewComment}
                          multiline
                          numberOfLines={2}
                          onKeyPress={(e) => {
                            if (e.nativeEvent.key === 'Enter') {
                              e.preventDefault();
                              handlePostComment();
                            }
                          }}
                          blurOnSubmit={false}
                          onFocus={() => {
                            // Scroll to comment input when focused (mobile only)
                            if (Platform.OS !== 'web') {
                              setTimeout(() => {
                                scrollToInputField(commentInputRef, 'comment');
                              }, 100);
                            }
                          }}
                        />
                        <TouchableOpacity
                          onPress={handlePostComment}
                          disabled={!newComment.trim() || isPostingComment}
                          style={[styles.postCommentButton, {
                            backgroundColor: newComment.trim() ? iconColors[5] : COLORS.grayscale400,
                          }]}
                        >
                          {isPostingComment ? (
                            <ActivityIndicator size="small" color={COLORS.white} />
                          ) : (
                            <Ionicons name="send" size={16} color={COLORS.white} />
                          )}
                        </TouchableOpacity>
                      </View>
                    </View>
                    
                    {/* Comments List */}
                    {comments.length > 0 && (
                      <View style={styles.commentsList}>
                        {comments.map((comment) => (
                          <View key={comment.id} style={styles.commentItem}>
                            <UserAvatar
                              size={32}
                              userId={comment.user_id}
                              style={styles.commentAvatar}
                            />
                            <View style={styles.commentContent}>
                              <Text style={[styles.commentAuthor, {
                                color: dark ? COLORS.white : COLORS.greyscale900,
                              }]}>
                                {comment.user?.full_name || 'Fetching name...'}
                              </Text>
                              <Text style={[styles.commentText, {
                                color: dark ? COLORS.white : COLORS.greyscale900,
                              }]}>
                                {comment.content}
                              </Text>
                              <Text style={[styles.commentDate, {
                                color: dark ? COLORS.grayscale400 : COLORS.grayscale700,
                              }]}>
                                {new Date(comment.created_at).toLocaleDateString()}
                              </Text>
                            </View>
                          </View>
                        ))}
                      </View>
                    )}
                  </View>
                </>
              )}
            </ScrollView>

            {/* Footer */}
            <View style={styles.footer}>
              {/* Footer content can be added here if needed in the future */}
            </View>
          </Animated.View>
        </Animated.View>
      </Modal>

      {/* Toast */}
      <Toast
        visible={toast.visible}
        message={toast.message}
        type={toast.type}
        onHide={hideToast}
      />

      {/* Task Reassignment Modal - Rendered outside main modal to prevent conflicts */}
      {(() => {
        console.log('ðŸŸ¡ TaskDetailsModal: showReassignmentModal state:', showReassignmentModal, 'task exists:', !!task, 'task title:', task?.title);
        console.log('ðŸŸ¡ TaskDetailsModal: Platform:', Platform.OS);
        return null;
      })()}
      {showReassignmentModal && task && (
        (() => {
          const projectId = task?.project_id || project?.id || '';
          console.log('ðŸŸ¡ TaskDetailsModal: Rendering TaskReassignmentModal with props:', {
            visible: showReassignmentModal,
            taskId: task?.id,
            taskTitle: task?.title,
            projectId: projectId,
            hasProjectId: !!projectId,
            platform: Platform.OS
          });
          return (
            <TaskReassignmentModal
              visible={showReassignmentModal}
              onClose={() => {
                console.log('ðŸŸ¡ TaskDetailsModal: Closing TaskReassignmentModal');
                console.log('ðŸŸ¡ TaskDetailsModal: Platform:', Platform.OS);
                setShowReassignmentModal(false);
              }}
              task={task}
              projectId={projectId}
              onReassign={handleTaskReassign}
            />
          );
        })()
      )}

      {/* Calendar Modal - Rendered outside main modal to prevent iOS stacking issues */}
      {(() => {
        console.log('ðŸŸ¢ TaskDetailsModal: Rendering CalendarBottomSheetModal');
        console.log('ðŸŸ¢ TaskDetailsModal: Platform:', Platform.OS);
        console.log('ðŸŸ¢ TaskDetailsModal: showDatePicker state:', showDatePicker);
        console.log('ðŸŸ¢ TaskDetailsModal: task exists:', !!task);
        console.log('ðŸŸ¢ TaskDetailsModal: task due_date:', task?.due_date);
        return null;
      })()}
      <CalendarBottomSheetModal
        visible={showDatePicker}
        onClose={() => {
          console.log('ðŸŸ¢ TaskDetailsModal: Closing CalendarBottomSheetModal');
          console.log('ðŸŸ¢ TaskDetailsModal: Platform:', Platform.OS);
          setShowDatePicker(false);
        }}
        title="Select Due Date"
        iconColor={iconColors[3]}
        selectedDate={task?.due_date || new Date().toISOString().split('T')[0]}
        onSelectDate={async (dateString) => {
          console.log('ðŸŸ¢ TaskDetailsModal: Date selected:', dateString);
          console.log('ðŸŸ¢ TaskDetailsModal: Platform:', Platform.OS);
          console.log('ðŸŸ¢ TaskDetailsModal: Task exists:', !!task);
          console.log('ðŸŸ¢ TaskDetailsModal: Task ID:', task?.id);
          
          if (task) {
            try {
              console.log('ðŸŸ¢ TaskDetailsModal: Updating task due date');
              await ProjectService.updateTask(task.id, { due_date: dateString });
              setTask(prev => prev ? { ...prev, due_date: dateString } : null);
              console.log('ðŸŸ¢ TaskDetailsModal: Task due date updated successfully');
            } catch (error) {
              console.error('ðŸŸ¢ TaskDetailsModal: Error updating due date:', error);
              Alert.alert('Error', 'Failed to update due date');
            }
          }
          console.log('ðŸŸ¢ TaskDetailsModal: Closing date picker');
          setShowDatePicker(false);
        }}
        minDate={new Date().toISOString().split('T')[0]}
        maxDate="2099-12-31"
        markedDates={{
          [task?.due_date || '']: {
            selected: true,
            selectedColor: iconColors[3],
          },
        }}
        theme={{
          backgroundColor: dark ? COLORS.dark2 : COLORS.white,
          calendarBackground: dark ? COLORS.dark2 : COLORS.white,
          textSectionTitleColor: dark ? COLORS.white : COLORS.greyscale900,
          selectedDayBackgroundColor: iconColors[3],
          selectedDayTextColor: COLORS.white,
          todayTextColor: iconColors[3],
          dayTextColor: dark ? COLORS.white : COLORS.greyscale900,
          textDisabledColor: dark ? COLORS.grayscale700 : COLORS.grayscale400,
          dotColor: iconColors[3],
          selectedDotColor: COLORS.white,
          arrowColor: dark ? COLORS.white : COLORS.greyscale900,
          monthTextColor: dark ? COLORS.white : COLORS.greyscale900,
          indicatorColor: iconColors[3],
          textDayFontFamily: 'regular',
          textMonthFontFamily: 'semiBold',
          textDayHeaderFontFamily: 'medium',
          textDayFontWeight: '300',
          textMonthFontWeight: 'bold',
          textDayHeaderFontWeight: '300',
          textDayFontSize: 16,
          textMonthFontSize: 16,
          textDayHeaderFontSize: 13,
        }}
      />

      {/* Delete Confirmation Modal - Rendered outside main modal to prevent iOS stacking issues */}
      {(() => {
        console.log('ðŸ”´ TaskDetailsModal: Rendering delete confirmation modal, visible:', showDeleteConfirmation);
        console.log('ðŸ”´ TaskDetailsModal: Task exists for delete modal:', !!task);
        console.log('ðŸ”´ TaskDetailsModal: Task title for delete modal:', task?.title);
        console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
        console.log('ðŸ”´ TaskDetailsModal: Main modal visible:', visible);
        console.log('ðŸ”´ TaskDetailsModal: About to render delete confirmation Modal, visible:', showDeleteConfirmation);
        console.log('ðŸ”´ TaskDetailsModal: Current isDeleting state:', isDeleting);
        return null;
      })()}
      <Modal
        visible={showDeleteConfirmation}
        transparent={true}
        animationType="slide"
        onRequestClose={() => {
          console.log('ðŸ”´ TaskDetailsModal: Delete confirmation modal onRequestClose called');
          console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
          hideDeleteConfirmationModal();
        }}
        statusBarTranslucent={true}
        presentationStyle="overFullScreen"
        hardwareAccelerated={true}
        supportedOrientations={['portrait', 'landscape']}
        onShow={() => {
          console.log('ðŸ”´ TaskDetailsModal: Delete confirmation modal onShow called');
          console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
          console.log('ðŸ”´ TaskDetailsModal: Modal visible state:', showDeleteConfirmation);
          console.log('ðŸ”´ TaskDetailsModal: Task title:', task?.title);
        }}
        onDismiss={() => {
          console.log('ðŸ”´ TaskDetailsModal: Delete confirmation modal onDismiss called');
          console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
        }}
      >
        <View style={styles.deleteModalOverlay}>
          <TouchableOpacity
            style={styles.deleteModalOverlayTouchable}
            activeOpacity={1}
            onPress={() => {
              console.log('ðŸ”´ TaskDetailsModal: Overlay pressed in delete confirmation modal');
              console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
              hideDeleteConfirmationModal();
            }}
          />
          <View style={[styles.deleteModalContainer, {
            backgroundColor: dark ? COLORS.dark2 : COLORS.white,
          }]}>
            <View style={styles.deleteModalContentContainer}>
              {/* Drag Handle */}
              <View style={styles.dragHandle}>
                <View style={[styles.dragIndicator, {
                  backgroundColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                }]} />
              </View>

              <View
                style={[
                  styles.deleteConfirmationContainer,
                  {
                    backgroundColor: dark ? COLORS.dark2 : COLORS.white,
                  },
                ]}
              >
                <View style={styles.confirmationContent}>
                  <Ionicons 
                    name="warning" 
                    size={48} 
                    color="#FF6B6B" 
                    style={styles.warningIcon}
                  />
                  <Text style={[styles.confirmationTitle, { 
                    color: dark ? COLORS.white : COLORS.greyscale900 
                  }]}>
                    Delete Task
                  </Text>
                  <Text style={[styles.confirmationMessage, { 
                    color: dark ? COLORS.grayscale200 : COLORS.grayscale700 
                  }]}>
                    Are you sure you want to delete "{task?.title}"? This action cannot be undone and will remove all associated data.
                  </Text>
                  <View style={styles.confirmationButtons}>
                    <TouchableOpacity
                      style={[styles.confirmationButton, styles.confirmationCancelButton, {
                        backgroundColor: dark ? COLORS.grayscale700 : COLORS.grayscale200,
                      }]}
                      onPress={() => {
                        console.log('ðŸ”´ TaskDetailsModal: Cancel button pressed in delete confirmation modal');
                        console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
                        console.log('ðŸ”´ TaskDetailsModal: Current isDeleting state:', isDeleting);
                        hideDeleteConfirmationModal();
                      }}
                      disabled={isDeleting}
                      activeOpacity={0.7}
                      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                    >
                      <Text style={[styles.confirmationCancelButtonText, { 
                        color: dark ? COLORS.white : COLORS.greyscale900 
                      }]}>
                        Cancel
                      </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                      style={[styles.confirmationButton, styles.confirmationDeleteButton, {
                        opacity: isDeleting ? 0.6 : 1,
                      }]}
                      onPress={() => {
                        console.log('ðŸ”´ TaskDetailsModal: Delete button pressed in delete confirmation modal');
                        console.log('ðŸ”´ TaskDetailsModal: Platform:', Platform.OS);
                        console.log('ðŸ”´ TaskDetailsModal: Current isDeleting state:', isDeleting);
                        console.log('ðŸ”´ TaskDetailsModal: Task ID:', task?.id);
                        console.log('ðŸ”´ TaskDetailsModal: Task title:', task?.title);
                        executeTaskDeletion();
                      }}
                      disabled={isDeleting}
                      activeOpacity={0.7}
                      hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                    >
                      {isDeleting ? (
                        <ActivityIndicator size="small" color={COLORS.white} />
                      ) : (
                        <Text style={styles.confirmationDeleteButtonText}>
                          Delete
                        </Text>
                      )}
                    </TouchableOpacity>
                  </View>
                </View>
              </View>
            </View>
          </View>
        </View>
      </Modal>
    </>
  );
};

const styles = StyleSheet.create({
  overlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    justifyContent: 'flex-end',
    zIndex: 1000,
    backgroundColor: 'rgba(0, 0, 0, 0.5)', // Semi-transparent background for overlay effect
  },
  overlayTouchable: {
    flex: 1,
    justifyContent: 'flex-end',
  },
  modalContainer: {
    position: 'absolute',
    bottom: 0,
    left: 0,
    right: 0,
    height: '90%',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    backgroundColor: COLORS.white,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: -2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 1001,
    zIndex: 1001,
  },
  dragHandle: {
    alignItems: 'center',
    paddingVertical: 8,
  },
  dragIndicator: {
    width: 40,
    height: 4,
    borderRadius: 2,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingBottom: 16,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.grayscale200,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  titleIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  titleContainer: {
    flex: 1,
    marginLeft: 12,
  },
  title: {
    fontSize: 20,
    fontFamily: 'bold',
  },
  editHint: {
    fontSize: 12,
    fontFamily: 'regular',
    marginTop: 2,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  closeButton: {
    padding: 4,
  },
  navigationContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.grayscale200,
  },
  navButton: {
    padding: 8,
  },
  navigationTitle: {
    fontSize: 14,
    fontFamily: 'medium',
    marginHorizontal: 16,
  },
  content: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 20,
  },
  contentContainer: {
    flexGrow: 1,
    paddingBottom: 20,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 40,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    fontFamily: 'regular',
  },
  inputSection: {
    marginBottom: 20,
  },
  labelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  label: {
    fontSize: 16,
    fontFamily: 'semiBold',
    marginLeft: 8,
  },
  input: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
    fontFamily: 'regular',
  },
  textArea: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
    fontFamily: 'regular',
    minHeight: 80,
    textAlignVertical: 'top',
  },
  editContainer: {
    marginTop: 8,
  },
  saveEditButton: {
    padding: 8,
  },
  cancelEditButton: {
    padding: 8,
  },
  taskTitle: {
    fontSize: 20,
    fontFamily: 'bold',
    lineHeight: 28,
  },
  taskDescription: {
    fontSize: 16,
    fontFamily: 'regular',
    lineHeight: 24,
    flex: 1,
  },
  dueDate: {
    fontSize: 16,
    fontFamily: 'medium',
  },
  editableField: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 8,
  },
  subtasksList: {
    gap: 8,
  },
  subtaskItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
    marginBottom: 8,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 1,
    },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  subtaskCheckbox: {
    marginRight: 12,
  },
  subtaskText: {
    flex: 1,
    fontSize: 16,
    fontFamily: 'regular',
  },
  deleteButton: {
    padding: 12,
    borderRadius: 20,
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(239, 68, 68, 0.1)',
    borderWidth: 1,
    borderColor: 'rgba(239, 68, 68, 0.2)',
    ...(Platform.OS === 'web' ? {
      zIndex: 10,
      pointerEvents: 'auto',
      cursor: 'pointer',
      backgroundColor: 'rgba(255,255,255,0.01)',
    } : {}),
  },
  emptyText: {
    fontSize: 14,
    fontFamily: 'regular',
    fontStyle: 'italic',
    textAlign: 'center',
    paddingVertical: 20,
  },
  commentInputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginBottom: 16,
  },
  commentInputAvatar: {
    marginRight: 12,
  },
  commentInputSection: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'flex-end',
  },
  commentInput: {
    flex: 1,
    fontSize: 16,
    fontFamily: 'regular',
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    paddingVertical: 8,
    marginRight: 8,
    minHeight: 40,
  },
  postCommentButton: {
    padding: 8,
    borderRadius: 8,
    width: 36,
    height: 36,
    alignItems: 'center',
    justifyContent: 'center',
  },
  commentsList: {
    gap: 12,
  },
  commentItem: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  commentAvatar: {
    marginRight: 12,
  },
  commentContent: {
    flex: 1,
  },
  commentAuthor: {
    fontSize: 14,
    fontFamily: 'bold',
    marginBottom: 4,
  },
  commentText: {
    fontSize: 16,
    fontFamily: 'regular',
    lineHeight: 24,
    marginBottom: 4,
  },
  commentDate: {
    fontSize: 12,
    fontFamily: 'regular',
  },
  footer: {
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 20,
    borderTopWidth: 1,
    borderTopColor: COLORS.grayscale200,
  },
  deleteTaskButton: {
    backgroundColor: COLORS.error,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 12,
    borderRadius: 8,
    gap: 8,
  },
  deleteTaskText: {
    color: COLORS.white,
    fontSize: 16,
    fontFamily: 'bold',
  },
  dateButton: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginTop: 8,
  },
  dateText: {
    fontSize: 16,
    fontFamily: 'regular',
  },
  datePickerOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'transparent',
    justifyContent: 'flex-end',
    zIndex: 2000,
  },
  datePickerOverlayTouchable: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'transparent',
  },
  datePickerContainer: {
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -8 },
    shadowOpacity: 0.25,
    shadowRadius: 16,
    elevation: 2001,
    zIndex: 2001,
    paddingBottom: 20,
  },
  datePickerContentContainer: {
    flex: 1,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
  },
  datePickerHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: COLORS.grayscale200,
  },
  datePickerTitleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  datePickerButton: {
    fontSize: 16,
    fontFamily: 'medium',
  },
  addSubtaskButton: {
    padding: 8,
    marginLeft: 'auto',
  },
  subtaskInputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    marginBottom: 16,
    gap: 8,
  },
  subtaskInput: {
    flex: 1,
    fontSize: 16,
    fontFamily: 'regular',
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    minHeight: 40,
    textAlignVertical: 'top',
  },
  addSubtaskActionButton: {
    padding: 8,
    borderRadius: 12,
    width: 44,
    height: 44,
    alignItems: 'center',
    justifyContent: 'center',
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
  },
  progressBar: {
    flex: 1,
    height: 12,
    borderRadius: 6,
    backgroundColor: COLORS.grayscale200,
  },
  progressFill: {
    height: '100%',
    borderRadius: 6,
  },
  progressText: {
    marginLeft: 8,
    fontSize: 12,
    fontFamily: 'regular',
  },
  descriptionContainer: {
    borderWidth: 1,
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 12,
    marginBottom: 8,
  },
  descriptionText: {
    fontSize: 16,
    fontFamily: 'regular',
    marginBottom: 4,
  },
  editActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 8,
    marginTop: 8,
  },
  cancelEditText: {
    color: COLORS.error,
    fontSize: 16,
    fontFamily: 'regular',
  },
  saveEditText: {
    color: COLORS.primary,
    fontSize: 16,
    fontFamily: 'regular',
  },
  reassignButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 8,
    borderWidth: 1,
    marginLeft: 8,
  },
  reassignButtonText: {
    fontSize: 14,
    fontFamily: 'medium',
    marginLeft: 4,
  },
  assignedUsersContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    flexWrap: 'wrap',
    marginTop: 8,
    gap: 8,
  },
  assignedUserItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.grayscale100,
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 16,
  },
  assignedUserName: {
    fontSize: 14,
    fontFamily: 'medium',
    marginLeft: 8,
  },
  noAssigneesContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderWidth: 1,
    borderColor: COLORS.grayscale200,
    borderRadius: 12,
    backgroundColor: COLORS.grayscale100,
  },
  noAssigneesText: {
    fontSize: 16,
    fontFamily: 'regular',
    marginLeft: 8,
  },
  // Confirmation modal styles
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  deleteModalOverlay: {
    flex: 1,
    backgroundColor: 'transparent',
    justifyContent: 'flex-end',
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: 9999,
  },
  deleteModalOverlayTouchable: {
    flex: 1,
    backgroundColor: 'transparent',
  },
  deleteModalContainer: {
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    width: '100%',
    maxHeight: '60%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: -8 },
    shadowOpacity: 0.25,
    shadowRadius: 16,
    elevation: 999999,
    zIndex: 10000,
  },
  deleteModalContentContainer: {
    flex: 1,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
  },
  confirmationContainer: {
    marginHorizontal: 20,
    borderRadius: 16,
    shadowColor: '#000',
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  deleteConfirmationContainer: {
    flex: 1,
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    paddingHorizontal: 24,
    paddingTop: 16,
    paddingBottom: 24,
    ...(Platform.OS === 'ios' ? {
      paddingBottom: 34, // Account for iOS home indicator
    } : {}),
  },
  confirmationContent: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  warningIcon: {
    marginBottom: 16,
  },
  confirmationTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 12,
    textAlign: 'center',
  },
  confirmationMessage: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 24,
    lineHeight: 22,
  },
  confirmationButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    width: '100%',
  },
  confirmationButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  confirmationCancelButton: {
    marginRight: 8,
  },
  confirmationDeleteButton: {
    backgroundColor: '#FF6B6B',
    marginLeft: 8,
  },
  confirmationCancelButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  confirmationDeleteButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: COLORS.white,
  },
  // Calendar Modal Styles
  calendarOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0,0,0,0.5)',
    zIndex: 1,
  },
  calendarCenteredView: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    zIndex: 2,
  },
  calendarModalWrapper: {
    width: '92%',
    maxHeight: '90%',
    borderRadius: 20,
    padding: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 8,
    elevation: 10,
  },
});

export default TaskDetailsModal; 